From 0c3e58db8467b6a08d5fcd2e89f9b30da8da916a Mon Sep 17 00:00:00 2001
From: phuel <phuel@gmx.de>
Date: Mon, 29 Jul 2019 11:41:50 +0200
Subject: [PATCH] Added 'extract' to access individual files in am archive.

---
 doc/fsarchiver.8                     |  16 +
 src/common.c                         |  16 +
 src/common.h                         |   1 +
 src/fsarchiver.c                     |  23 +-
 src/fsarchiver.h                     |   2 +-
 src/oper_restore.c                   | 438 +++++++++++++++++++--------
 src/options.h                        |   1 +
 website/content/quickstart/_index.md |   8 +
 8 files changed, 381 insertions(+), 124 deletions(-)

diff --git a/doc/fsarchiver.8 b/doc/fsarchiver.8
index e70cc34..aadb628 100644
--- a/doc/fsarchiver.8
+++ b/doc/fsarchiver.8
@@ -108,6 +108,9 @@ file and its contents.
 .TP
 .B probe
 Show list of filesystems detected on the disks.
+.TP
+.B extract
+Show archive contents or extract files from the archive.
 
 .SH "OPTIONS"
 .PP
@@ -147,6 +150,13 @@ name or an absolute file/dir path. You must use quotes around the pattern
 each time you use wildcards, else it would be interpreted by the shell. The
 wildcards must be interpreted by fsarchiver. See examples below for more
 details about this option.
+.IP "\fB\-i pattern, \-\-include=pattern\fP"
+Include files and directories that match specified pattern. The pattern can
+contain shell wildcards such as * and ? or may be either a simple file/dir
+name or an absolute file/dir path. You must use quotes around the pattern
+each time you use wildcards, else it would be interpreted by the shell. The
+wildcards must be interpreted by fsarchiver. If no include pattern is
+specified all files are included.
 .IP "\fB\-L label, \-\-label=label\fP"
 Set the label of the archive: it is just a comment about its contents. It
 can be used to remember a particular thing about the archive or the state
@@ -220,6 +230,12 @@ fsarchiver savefs -c - /data/myarchive1.fsa /dev/sda1
 fsarchiver restdir /data/linux-sources.fsa /tmp/extract
 .SS show information about an archive and its filesystems:
 fsarchiver archinfo /data/myarchive2.fsa
+.SS show the content of an archives:
+fsarchiver extract /data/myarchive2.fsa id=0
+.SS show the content of a directory in an archive:
+fsarchiver extract /data/myarchive2.fsa id=0 -i '/dir1/dir2/*'
+.SS extract a file from an archive:
+fsarchiver extract /data/myarchive2.fsa id=0,dest=targetdir -i '/dir/file'
 
 .SH WARNING
 .B fsarchiver
diff --git a/src/common.c b/src/common.c
index 4e99b42..1b70736 100644
--- a/src/common.c
+++ b/src/common.c
@@ -592,6 +592,22 @@ int exclude_check(cstrlist *patlist, char *string)
     return false;
 }
 
+int include_check(cstrlist *patlist, char *string)
+{
+    char pattern[1024];
+    int count;
+    int i;
+    
+    count=strlist_count(patlist);
+    for (i=0; i < count; i++)
+    {
+        strlist_getitem(patlist, i, pattern, sizeof(pattern));
+        if (fnmatch(pattern, string, 0)==0)
+            return true;
+    }
+    return false;
+}
+
 int get_path_to_volume(char *newvolbuf, int bufsize, char *basepath, long curvol)
 {
     char prefix[PATH_MAX];
diff --git a/src/common.h b/src/common.h
index bbe1eb8..391f612 100644
--- a/src/common.h
+++ b/src/common.h
@@ -49,6 +49,7 @@ int format_stacktrace(char *buffer, int bufsize);
 int stats_show(struct s_stats, int fsid);
 u64 stats_errcount(struct s_stats stats);
 int exclude_check(struct s_strlist *patlist, char *string);
+int include_check(struct s_strlist *patlist, char *string);
 int get_path_to_volume(char *newvolbuf, int bufsize, char *basepath, long curvol);
 s64 get_device_size(char *partition);
 
diff --git a/src/fsarchiver.c b/src/fsarchiver.c
index 7a1afdd..e257707 100644
--- a/src/fsarchiver.c
+++ b/src/fsarchiver.c
@@ -79,6 +79,7 @@ void usage(char *progname, bool examples)
     msgprintf(MSG_FORCE, " * restdir: restore data from an archive which is not based on a filesystem\n");
     msgprintf(MSG_FORCE, " * archinfo: show information about an existing archive file and its contents\n");
     msgprintf(MSG_FORCE, " * probe [detailed]: show list of filesystems detected on the disks\n");
+    msgprintf(MSG_FORCE, " * extract: Show the content of an archive or extract files from the archive\n");
     msgprintf(MSG_FORCE, "<options>\n");
     msgprintf(MSG_FORCE, " -o: overwrite the archive if it already exists instead of failing\n");
     msgprintf(MSG_FORCE, " -v: verbose mode (can be used several times to increase the level of details)\n");
@@ -87,6 +88,7 @@ void usage(char *progname, bool examples)
     msgprintf(MSG_FORCE, " -a: allow to save a filesystem when acls and xattrs are not supported\n");
     msgprintf(MSG_FORCE, " -x: enable support for experimental features (they are disabled by default)\n");
     msgprintf(MSG_FORCE, " -e <pattern>: exclude files and directories that match that pattern\n");
+    msgprintf(MSG_FORCE, " -i <pattern>: include files and directories that match that pattern\n");
     msgprintf(MSG_FORCE, " -L <label>: set the label of the archive (comment about the contents)\n");
     msgprintf(MSG_FORCE, " -z <level>: legacy compression level from 0 (very fast) to 9 (very good)\n");
 #ifdef OPTION_ZSTD_SUPPORT
@@ -138,6 +140,12 @@ void usage(char *progname, bool examples)
         msgprintf(MSG_FORCE, "   fsarchiver restdir /data/linux-sources.fsa /tmp/extract\n");
         msgprintf(MSG_FORCE, " * \e[1mshow information about an archive and its filesystems:\e[0m\n");
         msgprintf(MSG_FORCE, "   fsarchiver archinfo /data/myarchive2.fsa\n");
+        msgprintf(MSG_FORCE, " * \e[1mshow the content of an archives:\e[0m\n");
+        msgprintf(MSG_FORCE, "   fsarchiver extract /data/myarchive2.fsa id=0\n");
+        msgprintf(MSG_FORCE, " * \e[1mshow the content of a directory in an archive:\e[0m\n");
+        msgprintf(MSG_FORCE, "   fsarchiver extract /data/myarchive2.fsa id=0 -i '/dir1/dir2/*'\n");
+        msgprintf(MSG_FORCE, " * \e[1mextract a file from an archive:\e[0m\n");
+        msgprintf(MSG_FORCE, "   fsarchiver extract /data/myarchive2.fsa id=0,dest=targetdir -i '/dir/file'\n");
     }
 }
 
@@ -157,6 +165,7 @@ static struct option const long_options[] =
     {"cryptpass", required_argument, NULL, 'c'},
     {"label", required_argument, NULL, 'L'},
     {"exclude", required_argument, NULL, 'e'},
+    {"include", required_argument, NULL, 'i'},
     {"experimental", no_argument, NULL, 'x'},
     {NULL, 0, NULL, 0}
 };
@@ -206,7 +215,7 @@ int process_cmdline(int argc, char **argv)
     g_options.compresslevel=FSA_DEF_COMPRESS_LEVEL; // default level for gzip
 #endif // OPTION_ZSTD_SUPPORT
 
-    while ((c = getopt_long(argc, argv, "oaAvdj:hVs:c:L:e:xz:Z:", long_options, NULL)) != EOF)
+    while ((c = getopt_long(argc, argv, "oaAvdj:hVs:c:L:e:i:xz:Z:", long_options, NULL)) != EOF)
     {
         switch (c)
         {
@@ -243,6 +252,9 @@ int process_cmdline(int argc, char **argv)
             case 'e': // exclude files/directories
                 strlist_add(&g_options.exclude, optarg);
                 break;
+            case 'i': // include files/directories
+                strlist_add(&g_options.include, optarg);
+                break;
             case 's': // split archive into several volumes
                 g_options.splitsize=((u64)atoll(optarg))*((u64)1024LL*1024LL);
                 if (g_options.splitsize==0)
@@ -360,10 +372,15 @@ int process_cmdline(int argc, char **argv)
         runasroot=false;
         argcok=(argc==1);
     }
+    else if (strcmp(command, "extract")==0)
+    {   cmd=OPER_EXTRACT;
+        runasroot=false;
+        argcok=(argc>=1);
+    }
     else if (strcmp(command, "probe")==0)
     {   cmd=OPER_PROBE;
         runasroot=true;
-        argcok=(argc<=1);
+        argcok=(argc==1 || argc==2);
     }
     else // command not found
     {   errprintf("[%s] is not a valid command.\n", command);
@@ -422,6 +439,7 @@ int process_cmdline(int argc, char **argv)
         case OPER_SAVEDIR:
         case OPER_RESTDIR:
         case OPER_ARCHINFO:
+        case OPER_EXTRACT:
             archive=*argv++, argc--;
             break;
         case OPER_PROBE:
@@ -460,6 +478,7 @@ int process_cmdline(int argc, char **argv)
         case OPER_RESTFS:
         case OPER_RESTDIR:
         case OPER_ARCHINFO:
+        case OPER_EXTRACT:
             ret=oper_restore(archive, fscount, partition, cmd);
             break;
         case OPER_PROBE:
diff --git a/src/fsarchiver.h b/src/fsarchiver.h
index 7c9ab21..0f444ed 100644
--- a/src/fsarchiver.h
+++ b/src/fsarchiver.h
@@ -30,7 +30,7 @@
 #endif
 
 // -------------------------------- fsarchiver commands ---------------------------------------------
-enum {OPER_NULL=0, OPER_SAVEFS, OPER_RESTFS, OPER_SAVEDIR, OPER_RESTDIR, OPER_ARCHINFO, OPER_PROBE};
+enum {OPER_NULL=0, OPER_SAVEFS, OPER_RESTFS, OPER_SAVEDIR, OPER_RESTDIR, OPER_ARCHINFO, OPER_PROBE, OPER_EXTRACT};
 
 // ----------------------------------- dico sections ------------------------------------------------
 enum {DICO_OBJ_SECTION_STDATTR=0, DICO_OBJ_SECTION_XATTR=1, DICO_OBJ_SECTION_WINATTR=2};
diff --git a/src/oper_restore.c b/src/oper_restore.c
index 92eb5f6..b12a56c 100644
--- a/src/oper_restore.c
+++ b/src/oper_restore.c
@@ -107,6 +107,15 @@ int is_filedir_excluded(char *relpath)
     return false; // no exclusion found for that file
 }
 
+// returns true if this file of a parent directory has been excluded
+int is_file_included(char *relpath)
+{
+    if (strlist_count(&g_options.include)==0)
+        return true;
+
+    return include_check(&g_options.include, relpath);
+}
+
 // convert an array of strings "id=x,dest=/dev/xxx,..." to an array of strdico
 int convert_argv_to_strdicos(cstrdico *dicoargv[], int argc, char *cmdargv[])
 {
@@ -166,6 +175,56 @@ int convert_argv_to_strdicos(cstrdico *dicoargv[], int argc, char *cmdargv[])
     return 0;
 }
 
+// convert an array of strings "id=x,dest=/dev/xxx,..." to an array of strdico
+int convert_argv_to_strdicos_for_extract(cstrdico *dicoargv[], int argc, char *cmdargv[])
+{
+    cstrdico *tmpdico=NULL;
+    s64 temp64;
+    int fsid;
+    int i;
+    
+    if (argc == 0)
+    {   errprintf("No filesystem id specified (at least one 'id=X' argument must be specified).\n");
+        return -1;
+    }
+
+    for (i=0; (i<argc) && (i < FSA_MAX_FSPERARCH) && (cmdargv[i]!=NULL); i++)
+    {
+        if ((tmpdico=strdico_alloc())==NULL)
+            return -1;
+        
+        // parse argument and write (key,value) pairs in the strdico object
+        if ((strdico_set_valid_keys(tmpdico, "id,dest")!=0) ||
+            (strdico_parse_string(tmpdico, cmdargv[i])!=0))
+        {   strdico_destroy(tmpdico);
+            return -1;
+        }
+        
+        // read and check "id=" key in the argument
+        if (strdico_get_s64(tmpdico, &temp64, "id")!=0)
+        {   errprintf("cannot find \"id=\" key in \"%s\"\n", cmdargv[i]);
+            strdico_destroy(tmpdico);
+            return -1;
+        }
+        fsid=temp64;
+        if ((fsid<0) || (fsid>FSA_MAX_FSPERARCH-1))
+        {   errprintf("invalid filesystem id [%d]: it must match a valid filesystem id as shown by archinfo\n", fsid);
+            strdico_destroy(tmpdico);
+            return -1;
+        }
+       
+        // add the current argument to the list of the strdico objects
+        if (dicoargv[fsid]!=NULL)
+        {   errprintf("you mentioned filesystem with id=%d multiple times, cannot continue\n", fsid);
+            strdico_destroy(tmpdico);
+            return -1;
+        }
+        dicoargv[fsid]=tmpdico;
+    }
+    
+    return 0;
+}
+
 int extractar_listing_print_file(cextractar *exar, int objtype, char *relpath)
 {
     char strprogress[256];
@@ -351,6 +410,19 @@ int extractar_restore_obj_symlink(cextractar *exar, char *fullpath, char *relpat
     if (is_filedir_excluded(relpath)==true)
         goto extractar_restore_obj_symlink_err;
     
+    if (is_file_included(relpath)!=true)
+        goto extractar_restore_obj_symlink_err;
+
+    if (dico_get_string(d, DICO_OBJ_SECTION_STDATTR, DISKITEMKEY_SYMLINK, buffer, PATH_MAX)<0)
+    {   errprintf("Cannot read field=symlink for file=[%s]\n", relpath);
+        goto extractar_restore_obj_symlink_err;
+    }
+    
+    if (destdir==NULL)
+    {   printf("%s %s\t%s\n", get_objtype_name(objtype), relpath, buffer);
+        goto extractar_restore_obj_symlink_err;
+    }
+
     // update progress bar
     extractar_listing_print_file(exar, objtype, relpath);
 
@@ -361,11 +433,6 @@ int extractar_restore_obj_symlink(cextractar *exar, char *fullpath, char *relpat
     // backup parent dir atime/mtime
     get_parent_dir_time_attrib(fullpath, parentdir, sizeof(parentdir), tv);
     
-    if (dico_get_string(d, DICO_OBJ_SECTION_STDATTR, DISKITEMKEY_SYMLINK, buffer, PATH_MAX)<0)
-    {   errprintf("Cannot read field=symlink for file=[%s]\n", fullpath);
-        goto extractar_restore_obj_symlink_err;
-    }
-    
     // in ntfs a symlink has to be recreated as a standard file or directory (depending on what the target is)
     if ((dico_get_u64(d, DICO_OBJ_SECTION_STDATTR, DISKITEMKEY_LINKTARGETTYPE, &targettype)==0)
          && (strcmp(filesys[fstype].name, "ntfs")==0))
@@ -439,6 +506,19 @@ int extractar_restore_obj_hardlink(cextractar *exar, char *fullpath, char *relpa
     if (is_filedir_excluded(relpath)==true)
         goto extractar_restore_obj_hardlink_err;
     
+    if (is_file_included(relpath)!=true)
+        goto extractar_restore_obj_hardlink_err;
+
+    if (dico_get_string(d, DICO_OBJ_SECTION_STDATTR, DISKITEMKEY_HARDLINK, buffer, PATH_MAX)<0)
+    {   msgprintf(MSG_STACK, "dico_get_string(DICO_OBJ_SECTION_STDATTR, DISKITEMKEY_HARDLINK) failed\n");
+        goto extractar_restore_obj_hardlink_err;
+    }
+    
+    if (destdir==NULL)
+    {   printf("%s %s\t%s\n", get_objtype_name(objtype), relpath, buffer);
+        goto extractar_restore_obj_hardlink_err;
+    }
+
     // create parent directory first
     extract_dirpath(fullpath, parentdir, sizeof(parentdir));
     mkdir_recursive(parentdir);
@@ -449,11 +529,6 @@ int extractar_restore_obj_hardlink(cextractar *exar, char *fullpath, char *relpa
     // update progress bar
     extractar_listing_print_file(exar, objtype, relpath);
     
-    if (dico_get_string(d, DICO_OBJ_SECTION_STDATTR, DISKITEMKEY_HARDLINK, buffer, PATH_MAX)<0)
-    {   msgprintf(MSG_STACK, "dico_get_string(DICO_OBJ_SECTION_STDATTR, DISKITEMKEY_HARDLINK) failed\n");
-        goto extractar_restore_obj_hardlink_err;
-    }
-    
     concatenate_paths(regfile, PATH_MAX, destdir, buffer);
     
     if ((res=link(regfile, fullpath))!=0)
@@ -496,6 +571,14 @@ int extractar_restore_obj_devfile(cextractar *exar, char *fullpath, char *relpat
     if (is_filedir_excluded(relpath)==true)
         goto extractar_restore_obj_devfile_err;
     
+    if (is_file_included(relpath)!=true)
+        goto extractar_restore_obj_devfile_err;
+
+    if (destdir==NULL)
+    {   printf("%s %s\n", get_objtype_name(objtype), relpath);
+        goto extractar_restore_obj_devfile_err;
+    }
+    
     // create parent directory first
     extract_dirpath(fullpath, parentdir, sizeof(parentdir));
     mkdir_recursive(parentdir);
@@ -547,6 +630,14 @@ int extractar_restore_obj_directory(cextractar *exar, char *fullpath, char *relp
     if (is_filedir_excluded(relpath)==true)
         goto extractar_restore_obj_directory_err;
     
+    if (is_file_included(relpath)!=true)
+        goto extractar_restore_obj_directory_err;
+    
+    if (destdir==NULL)
+    {   printf("%s %s\n", get_objtype_name(objtype), relpath);
+        goto extractar_restore_obj_directory_err;
+    }
+
     // create parent directory first
     extract_dirpath(fullpath, parentdir, sizeof(parentdir));
     mkdir_recursive(parentdir);
@@ -580,16 +671,18 @@ int extractar_restore_obj_directory(cextractar *exar, char *fullpath, char *relp
     return 0; // non fatal error
 }
 
-int extractar_restore_obj_regfile_multi(cextractar *exar, char *destdir, cdico *dicofirstfile, int objtype, int fstype) // d = obj-header of first small file
+int extractar_restore_obj_regfile_multi(cextractar *exar, char *destdir, cdico *dicofirstfile, int objtype, int fstype, int oper) // d = obj-header of first small file
 {
     cdatafile *datafile=NULL;
     char databuf[FSA_MAX_SMALLFILESIZE];
     char basename[PATH_MAX];
     cdico *filehead=NULL;
     char magic[FSA_SIZEOF_MAGIC+1];
-    char fullpath[PATH_MAX];
+    char destpath[PATH_MAX];
+    char *fullpath=NULL;
     char relpath[PATH_MAX];
     char parentdir[PATH_MAX];
+    char buffer[256];
     struct timeval tv[2];
     struct s_blockinfo blkinfo;
     cregmulti regmulti;
@@ -668,63 +761,78 @@ int extractar_restore_obj_regfile_multi(cextractar *exar, char *destdir, cdico *
             dico_show(filehead, DICO_OBJ_SECTION_STDATTR, "DISKITEMKEY_PATH");
             goto extractar_restore_obj_regfile_multi_err;
         }
-        concatenate_paths(fullpath, sizeof(fullpath), destdir, relpath);
-        extract_basename(fullpath, basename, sizeof(basename));
-        
+        fullpath = NULL;
+        if (destdir != NULL)
+        {   concatenate_paths(destpath, sizeof(destpath), destdir, relpath);
+            fullpath=destpath;
+        }
+        extract_basename(relpath, basename, sizeof(basename));
+
         // update cost statistics and progress bar
         exar->cost_current+=FSA_COST_PER_FILE; 
         exar->cost_current+=datsize; // filesize
         
         // check the list of excluded files/dirs
-        if (is_filedir_excluded(relpath)!=true)
-        {
-            // create parent directory if necessary
-            extract_dirpath(fullpath, parentdir, sizeof(parentdir));
-            mkdir_recursive(parentdir);
-            
-            // backup parent dir atime/mtime
-            get_parent_dir_time_attrib(fullpath, parentdir, sizeof(parentdir), tv);
-            
-            extractar_listing_print_file(exar, tmpobjtype, relpath);
-            
-            if (dico_get_data(filehead, DICO_OBJ_SECTION_STDATTR, DISKITEMKEY_MD5SUM, md5sumorig, 16, NULL))
-            {   errprintf("cannot get md5sum from file footer for file=[%s]\n", relpath);
-                dico_show(filehead, DICO_OBJ_SECTION_STDATTR, "filehead");
-                goto extractar_restore_obj_regfile_multi_err;
-            }
-            
-            if (datafile_open_write(datafile, fullpath, false, false)<0)
-                goto extractar_restore_obj_regfile_multi_err;
-            
-            res=datafile_write(datafile, databuf, datsize);
-            
-            datafile_close(datafile, md5sumcalc, sizeof(md5sumcalc));
-            
-            if (res!=FSAERR_SUCCESS)
-            {   errprintf("removing %s\n", fullpath);
-                unlink(fullpath);
-                return -1;
-            }
-            
-            if (memcmp(md5sumcalc, md5sumorig, 16)!=0)
-            {   errprintf("cannot restore file %s, the data block (which is shared by multiple files) is corrupt\n", relpath);
-                res=truncate(fullpath, 0); // don't leave corrupt data in the file
-                goto extractar_restore_obj_regfile_multi_err;
-            }
-                      
-            if (extractar_restore_attr_everything(exar, objtype, fullpath, relpath, filehead)!=0)
+        if (is_filedir_excluded(relpath)==true)
+            goto extractar_restore_obj_regfile_multi_exclude;
+
+        if (is_file_included(relpath)!=true)
+            goto extractar_restore_obj_regfile_multi_exclude;
+
+        if (fullpath == NULL)
+        {   printf("%s %s\t%s\n", get_objtype_name(objtype), relpath, format_size(datsize, buffer, sizeof(buffer), 'h'));
+            goto extractar_restore_obj_regfile_multi_exclude;
+        }
+
+        // create parent directory if necessary
+        extract_dirpath(fullpath, parentdir, sizeof(parentdir));
+        mkdir_recursive(parentdir);
+        
+        // backup parent dir atime/mtime
+        get_parent_dir_time_attrib(fullpath, parentdir, sizeof(parentdir), tv);
+        
+        extractar_listing_print_file(exar, tmpobjtype, relpath);
+        
+        if (dico_get_data(filehead, DICO_OBJ_SECTION_STDATTR, DISKITEMKEY_MD5SUM, md5sumorig, 16, NULL))
+        {   errprintf("cannot get md5sum from file footer for file=[%s]\n", relpath);
+            dico_show(filehead, DICO_OBJ_SECTION_STDATTR, "filehead");
+            goto extractar_restore_obj_regfile_multi_err;
+        }
+        
+        if (datafile_open_write(datafile, fullpath, false, false)<0)
+            goto extractar_restore_obj_regfile_multi_err;
+        
+        res=datafile_write(datafile, databuf, datsize);
+        
+        datafile_close(datafile, md5sumcalc, sizeof(md5sumcalc));
+        
+        if (res!=FSAERR_SUCCESS)
+        {   errprintf("removing %s\n", fullpath);
+            unlink(fullpath);
+            return -1;
+        }
+        
+        if (memcmp(md5sumcalc, md5sumorig, 16)!=0)
+        {   errprintf("cannot restore file %s, the data block (which is shared by multiple files) is corrupt\n", relpath);
+            res=truncate(fullpath, 0); // don't leave corrupt data in the file
+            goto extractar_restore_obj_regfile_multi_err;
+        }
+                    
+        if (oper!=OPER_EXTRACT)
+        {   if (extractar_restore_attr_everything(exar, objtype, fullpath, relpath, filehead)!=0)
             {   msgprintf(MSG_STACK, "cannot restore file attributes for file [%s]\n", relpath);
                 goto extractar_restore_obj_regfile_multi_err;
             }
-            
-            // restore parent dir mtime/atime
-            if (utimes(parentdir, tv)!=0)
-            {   sysprintf("utimes(%s) failed\n", parentdir);
-                goto extractar_restore_obj_regfile_multi_err;
-            }
-            exar->stats.cnt_regfile++;
         }
         
+        // restore parent dir mtime/atime
+        if (utimes(parentdir, tv)!=0)
+        {   sysprintf("utimes(%s) failed\n", parentdir);
+            goto extractar_restore_obj_regfile_multi_err;
+        }
+        exar->stats.cnt_regfile++;
+        
+extractar_restore_obj_regfile_multi_exclude:
         dico_destroy(filehead);
         continue; // success on that file
         
@@ -738,11 +846,12 @@ int extractar_restore_obj_regfile_multi(cextractar *exar, char *destdir, cdico *
     return 0;
 }
 
-int extractar_restore_obj_regfile_unique(cextractar *exar, char *fullpath, char *relpath, char *destdir, cdico *d, int objtype, int fstype) // large or empty files
+int extractar_restore_obj_regfile_unique(cextractar *exar, char *fullpath, char *relpath, char *destdir, cdico *d, int objtype, int fstype, int oper) // large or empty files
 {
     char magic[FSA_SIZEOF_MAGIC+1];
     struct s_blockinfo blkinfo;
     char parentdir[PATH_MAX];
+    char buffer[256];
     cdatafile *datafile=NULL;
     cdico *footerdico=NULL;
     bool fatalerr=false; // error for restoration globally
@@ -775,11 +884,18 @@ int extractar_restore_obj_regfile_unique(cextractar *exar, char *fullpath, char
     exar->cost_current+=filesize;
     
     // check the list of excluded files/dirs
-    if (is_filedir_excluded(relpath)==true)
+    if (is_filedir_excluded(relpath)==true ||
+        is_file_included(relpath)!=true)
     {
         excluded=true;
     }
-    else if (minorerr==false) // file not excluded and no error yet
+
+    if (destdir==NULL && excluded==false)
+    {
+        printf("%s %s\t%s\n", get_objtype_name(objtype), relpath, format_size(filesize, buffer, sizeof(buffer), 'h'));
+        excluded=true;
+    }
+    else if (minorerr==false && excluded==false) // file not excluded and no error yet
     {
         // create parent directory first
         extract_dirpath(fullpath, parentdir, sizeof(parentdir));
@@ -830,9 +946,13 @@ int extractar_restore_obj_regfile_unique(cextractar *exar, char *fullpath, char
     
     if ((minorerr==false) && (excluded==false))
     {
-        if (extractar_restore_attr_everything(exar, objtype, fullpath, relpath, d)!=0)
-        {   msgprintf(MSG_STACK, "cannot restore file attributes for file [%s]\n", relpath);
-            minorerr=true;
+        // Don't restore attributes and ownership when extracting files.
+        if (oper!=OPER_EXTRACT)
+        {
+            if (extractar_restore_attr_everything(exar, objtype, fullpath, relpath, d)!=0)
+            {   msgprintf(MSG_STACK, "cannot restore file attributes for file [%s]\n", relpath);
+                minorerr=true;
+            }
         }
     
         // restore parent dir mtime/atime
@@ -851,7 +971,7 @@ int extractar_restore_obj_regfile_unique(cextractar *exar, char *fullpath, char
             goto restore_obj_regfile_unique_end;
         }
         
-        if (excluded!=true)
+        if (excluded==false)
         {
             if (memcmp(magic, FSA_MAGIC_FILF, FSA_SIZEOF_MAGIC)!=0)
             {   errprintf("header is not what we expected: found=[%s] and expected=[%s]\n", magic, FSA_MAGIC_FILF);
@@ -897,10 +1017,11 @@ int extractar_restore_obj_regfile_unique(cextractar *exar, char *fullpath, char
     return (fatalerr==false)?(0):(-1);
 }
 
-int extractar_restore_object(cextractar *exar, int *errors, char *destdir, cdico *dicoattr, int fstype)
+int extractar_restore_object(cextractar *exar, int *errors, char *destdir, cdico *dicoattr, int fstype, int oper)
 {
     char relpath[PATH_MAX];
-    char fullpath[PATH_MAX];
+    char destpath[PATH_MAX];
+    char *fullpath=NULL;
     u64 filesize;
     u32 objtype;
     int res;
@@ -914,7 +1035,11 @@ int extractar_restore_object(cextractar *exar, int *errors, char *destdir, cdico
         return -2;
     if (dico_get_u64(dicoattr, DICO_OBJ_SECTION_STDATTR, DISKITEMKEY_SIZE, &filesize)!=0)
         return -3;
-    concatenate_paths(fullpath, sizeof(fullpath), destdir, relpath);
+
+    if (destdir!= NULL)
+    {   concatenate_paths(destpath, sizeof(destpath), destdir, relpath);
+        fullpath=destpath;
+    }
     
     // ---- recreate specific object on the filesystem
     switch (objtype)
@@ -949,14 +1074,14 @@ int extractar_restore_object(cextractar *exar, int *errors, char *destdir, cdico
             break;
         case OBJTYPE_REGFILEUNIQUE:
             msgprintf(MSG_DEBUG2, "objtype=OBJTYPE_REGFILEUNIQUE, path=[%s]\n", relpath);
-            if ((res=extractar_restore_obj_regfile_unique(exar, fullpath, relpath, destdir, dicoattr, objtype, fstype))<0)
+            if ((res=extractar_restore_obj_regfile_unique(exar, fullpath, relpath, destdir, dicoattr, objtype, fstype, oper))<0)
             {   msgprintf(MSG_STACK, "restore_obj_regfile_unique(%s) failed with res=%d\n", relpath, res);
                 return -1;
             }
             break;
         case OBJTYPE_REGFILEMULTI:
             msgprintf(MSG_DEBUG2, "objtype=OBJTYPE_REGFILEMULTI, path=[%s]\n", relpath);
-            if ((res=extractar_restore_obj_regfile_multi(exar, destdir, dicoattr, objtype, fstype))<0)
+            if ((res=extractar_restore_obj_regfile_multi(exar, destdir, dicoattr, objtype, fstype, oper))<0)
             {   msgprintf(MSG_STACK, "restore_obj_regfile_multi(%s) failed with res=%d\n", relpath, res);
                 return -1;
             }
@@ -973,7 +1098,7 @@ int extractar_restore_object(cextractar *exar, int *errors, char *destdir, cdico
     return 0;
 }
 
-int extractar_extract_read_objects(cextractar *exar, int *errors, char *destdir, int fstype)
+int extractar_extract_read_objects(cextractar *exar, int *errors, char *destdir, int fstype, int oper)
 {
     char magic[FSA_SIZEOF_MAGIC+1];
     cdico *dicoattr=NULL;
@@ -1021,7 +1146,7 @@ int extractar_extract_read_objects(cextractar *exar, int *errors, char *destdir,
             
             if (checkfsid==exar->fsid) // if filesystem-id is correct
             {
-                if ((res=extractar_restore_object(exar, &curerr, destdir, dicoattr, fstype))!=0)
+                if ((res=extractar_restore_object(exar, &curerr, destdir, dicoattr, fstype, oper))!=0)
                 {   msgprintf(MSG_STACK, "restore_object() failed with res=%d\n", res);
                     //dico_destroy(dicoattr);
                     return -1; // fatal error
@@ -1171,7 +1296,7 @@ int extractar_read_mainhead(cextractar *exar, cdico **dicomainhead)
     return 0;
 }
 
-int extractar_filesystem_extract(cextractar *exar, cdico *dicofs, cstrdico *dicocmdline)
+int extractar_filesystem_extract(cextractar *exar, cdico *dicofs, cstrdico *dicocmdline, int oper)
 {
     char filesystem[FSA_MAX_FSNAMELEN];
     char text[FSA_MAX_FSNAMELEN];
@@ -1310,7 +1435,7 @@ int extractar_filesystem_extract(cextractar *exar, cdico *dicofs, cstrdico *dico
         return -1;
     }
     
-    if (extractar_extract_read_objects(exar, &errors, mntbuf, fstype)!=0)
+    if (extractar_extract_read_objects(exar, &errors, mntbuf, fstype, oper)!=0)
     {   msgprintf(MSG_STACK, "extract_read_objects(%s) failed\n", mntbuf);
         ret=-1;
         goto filesystem_extract_umount;
@@ -1345,6 +1470,32 @@ int extractar_filesystem_extract(cextractar *exar, cdico *dicofs, cstrdico *dico
     return ret;
 }
 
+int check_dir(char *dirname)
+{
+    struct stat64 st;
+
+    if (stat64(dirname, &st)!=0)
+    {   
+        switch (errno)
+        {
+            case ENOENT:
+                sysprintf("%s does not exist, cannot continue\n", dirname);
+                break;
+            default:
+                sysprintf("fstat64(%s) failed\n", dirname);
+                break;
+        }
+        return false;
+    }
+    
+    if (!S_ISDIR(st.st_mode))
+    {   errprintf("%s is not a valid directory, cannot continue\n", dirname);
+        return false;
+    }
+
+    return true;
+}
+
 int oper_restore(char *archive, int argc, char **argv, int oper)
 {
     cdico *dicofsinfo[FSA_MAX_FSPERARCH];
@@ -1354,7 +1505,6 @@ int oper_restore(char *archive, int argc, char **argv, int oper)
     cdico *dicomainhead=NULL;
     cdico *dirsinfo=NULL;
     pthread_t thread_reader;
-    struct stat64 st;
     char *destdir;
     cextractar exar;
     u64 totalerr=0;
@@ -1384,25 +1534,6 @@ int oper_restore(char *archive, int argc, char **argv, int oper)
     // set archive path
     snprintf(exar.ai.basepath, PATH_MAX, "%s", archive);
     
-    // convert the command line arguments to dicos and init g_fsbitmap
-    switch (oper)
-    {
-        case OPER_RESTFS:
-            // convert the arguments from the command line to dico
-            if (convert_argv_to_strdicos(dicoargv, argc, argv)!=0)
-            {   msgprintf(MSG_STACK, "convert_argv_to_dico() failed\n");
-                goto do_extract_error;
-            }
-            // say to the threadio_readarch thread which filesystems have to be read in archive
-            for (i=0; i<FSA_MAX_FSPERARCH; i++)
-                g_fsbitmap[i]=!!(dicoargv[i]!=NULL);
-            break;
-            
-        case OPER_RESTDIR: // the files are all considered as belonging to fsid==0
-            g_fsbitmap[0]=1;
-            break;
-    }
-
     // create decompression threads
     for (i=0; (i<g_options.compressjobs) && (i<FSA_MAX_COMPJOBS); i++)
     {
@@ -1439,13 +1570,7 @@ int oper_restore(char *archive, int argc, char **argv, int oper)
         (int)FSA_VERSION_GET_C(exar.ai.minfsaver), (int)FSA_VERSION_GET_D(exar.ai.minfsaver));
         goto do_extract_error;
     }
-    
-    // show archive information if command is OPER_ARCHINFO
-    if (oper==OPER_ARCHINFO && archinfo_show_mainhead(&exar.ai, dicomainhead)!=0)
-    {   errprintf("archinfo_show_mainhead(%s) failed\n", archive);
-        goto do_extract_error;
-    }
-    
+
     // check that the operation requested on the command line matches the archive type
     switch (exar.ai.archtype)
     {
@@ -1465,6 +1590,42 @@ int oper_restore(char *archive, int argc, char **argv, int oper)
             errprintf("this archive has an unknown type: %d, cannot continue\n", exar.ai.archtype);
             goto do_extract_error;
     }
+
+    // convert the command line arguments to dicos and init g_fsbitmap
+    switch (exar.ai.archtype)
+    {
+        case ARCHTYPE_FILESYSTEMS:
+            if (oper==OPER_RESTFS)
+            {
+                // convert the arguments from the command line to dico
+                if (convert_argv_to_strdicos(dicoargv, argc, argv)!=0)
+                {   msgprintf(MSG_STACK, "convert_argv_to_dico() failed\n");
+                    goto do_extract_error;
+                }
+            }
+            else if (oper==OPER_EXTRACT)
+            {
+                // convert the arguments from the command line to dico
+                if (convert_argv_to_strdicos_for_extract(dicoargv, argc, argv)!=0)
+                {   msgprintf(MSG_STACK, "convert_argv_to_dico() failed\n");
+                    goto do_extract_error;
+                }
+            }
+            // say to the threadio_readarch thread which filesystems have to be read in archive
+            for (i=0; i<FSA_MAX_FSPERARCH; i++)
+                g_fsbitmap[i]=!!(dicoargv[i]!=NULL);
+            break;
+            
+        case ARCHTYPE_DIRECTORIES: // the files are all considered as belonging to fsid==0
+            g_fsbitmap[0]=1;
+            break;
+    }
+    
+    // show archive information if command is OPER_ARCHINFO
+    if (oper==OPER_ARCHINFO && archinfo_show_mainhead(&exar.ai, dicomainhead)!=0)
+    {   errprintf("archinfo_show_mainhead(%s) failed\n", archive);
+        goto do_extract_error;
+    }
     
     // check the user did not specify an invalid filesystem id (id >= fscount)
     for (i=0; (i<FSA_MAX_FSPERARCH); i++)
@@ -1536,7 +1697,7 @@ int oper_restore(char *archive, int argc, char **argv, int oper)
                     exar.fsid=i;
                     memset(&exar.stats, 0, sizeof(exar.stats)); // init stats to zero
                     msgprintf(MSG_VERB1, "============= extracting filesystem %d =============\n", i);
-                    if (extractar_filesystem_extract(&exar, dicofsinfo[i], dicoargv[i])!=0)
+                    if (extractar_filesystem_extract(&exar, dicofsinfo[i], dicoargv[i], oper)!=0)
                     {   msgprintf(MSG_STACK, "extract_filesystem(%d) failed\n", i);
                         goto do_extract_error;
                     }
@@ -1551,27 +1712,11 @@ int oper_restore(char *archive, int argc, char **argv, int oper)
         {
             exar.fsid=0;
             destdir=argv[0];
-            if (stat64(destdir, &st)!=0)
-            {   
-                switch (errno)
-                {
-                    case ENOENT:
-                        sysprintf("%s does not exist, cannot continue\n", destdir);
-                        break;
-                    default:
-                        sysprintf("fstat64(%s) failed\n", destdir);
-                        break;
-                }
-                goto do_extract_error;
-            }
-            
-            if (!S_ISDIR(st.st_mode))
-            {   errprintf("%s is not a valid directory, cannot continue\n", destdir);
+            if (check_dir(destdir)!=true)
                 goto do_extract_error;
-            }
             
             memset(&exar.stats, 0, sizeof(exar.stats)); // init stats to zero
-            if (extractar_extract_read_objects(&exar, &errors, destdir, 0)!=0) // TODO: get the right fstype
+            if (extractar_extract_read_objects(&exar, &errors, destdir, 0, oper)!=0) // TODO: get the right fstype
             {   errprintf("extract_read_objects(%s) failed\n", destdir);
                 goto do_extract_error;
             }
@@ -1583,6 +1728,57 @@ int oper_restore(char *archive, int argc, char **argv, int oper)
             goto do_extract_error;
         }
     }
+    if (oper==OPER_EXTRACT)
+    {
+        if (exar.ai.archtype==ARCHTYPE_FILESYSTEMS)
+        {
+            for (i=0; (i < exar.ai.fscount) && (i < FSA_MAX_FSPERARCH) && (get_abort()==false); i++)
+            {
+                if (dicoargv[i]!=NULL) // that filesystem has been requested on the command line
+                {
+                    char fsdestdir[PATH_MAX];
+                    // read destination partition from dicocmdline
+                    if (strdico_get_string(dicoargv[i], fsdestdir, sizeof(fsdestdir), "dest")==0)
+                    {   
+                        destdir=fsdestdir;
+                        if (check_dir(destdir)!=true)
+                            goto do_extract_error;
+                    }
+                    else
+                    {
+                        destdir=NULL;
+                    }
+
+                    exar.fsid=i;
+                    memset(&exar.stats, 0, sizeof(exar.stats)); // init stats to zero
+                    msgprintf(MSG_VERB1, "============= extracting filesystem %d =============\n", i);
+                    if (extractar_extract_read_objects(&exar, &errors, destdir, i, oper)!=0)
+                    {   msgprintf(MSG_STACK, "extract_filesystem(%d) failed\n", i);
+                        goto do_extract_error;
+                    }
+                    if (get_abort()==false)
+                        stats_show(exar.stats, i);
+                    totalerr+=stats_errcount(exar.stats);
+                }
+            }
+        }
+        else if (exar.ai.archtype==ARCHTYPE_DIRECTORIES)
+        {
+            destdir=NULL;
+            if (argc > 0)
+            {
+                destdir=argv[0]; 
+                if (check_dir(destdir)!=true)
+                    goto do_extract_error;
+            }
+            exar.fsid=0;
+
+            if (extractar_extract_read_objects(&exar, &errors, destdir, 0, oper)!=0) // TODO: get the right fstype
+            {   errprintf("extract_read_objects(%s) failed\n", destdir);
+                goto do_extract_error;
+            }
+        }
+    }
     
     if (get_abort()==true)
         msgprintf(MSG_FORCE, "operation aborted by user\n");
diff --git a/src/options.h b/src/options.h
index ede6ebf..5fd90eb 100644
--- a/src/options.h
+++ b/src/options.h
@@ -42,6 +42,7 @@ struct s_options
 	char     archlabel[FSA_MAX_LABELLEN];
     u8       encryptpass[FSA_MAX_PASSLEN+1];
     cstrlist exclude;
+    cstrlist include;
 };
 
 extern coptions g_options;
diff --git a/website/content/quickstart/_index.md b/website/content/quickstart/_index.md
index b68947b..e5ee120 100644
--- a/website/content/quickstart/_index.md
+++ b/website/content/quickstart/_index.md
@@ -207,6 +207,7 @@ Distributed under the GPL v2 license (GNU General Public License v2).
  * restdir: restore data from an archive which is not based on a filesystem
  * archinfo: show information about an existing archive file and its contents
  * probe [detailed]: show list of filesystems detected on the disks
+ * extract: Show the content of an archive or extract files from the archive
 <options>
  -o: overwrite the archive if it already exists instead of failing
  -v: verbose mode (can be used several times to increase the level of details)
@@ -215,6 +216,7 @@ Distributed under the GPL v2 license (GNU General Public License v2).
  -a: allow to save a filesystem when acls and xattrs are not supported
  -x: enable support for experimental features (they are disabled by default)
  -e <pattern>: exclude files and directories that match that pattern
+ -i <pattern>: include files and directories that match that pattern
  -L <label>: set the label of the archive (comment about the contents)
  -z <level>: legacy compression level from 0 (very fast) to 9 (very good)
  -Z <level>: zstd compression level from 1 (very fast) to 22 (very good)
@@ -261,4 +263,10 @@ Distributed under the GPL v2 license (GNU General Public License v2).
    fsarchiver restdir /data/linux-sources.fsa /tmp/extract
  * show information about an archive and its filesystems:
    fsarchiver archinfo /data/myarchive2.fsa
+ * show the content of an archives:
+   fsarchiver extract /data/myarchive2.fsa id=0
+ * show the content of a directory in an archive:
+   fsarchiver extract /data/myarchive2.fsa id=0 -i '/dir1/dir2/*'
+ * extract a file from an archive:
+   fsarchiver extract /data/myarchive2.fsa id=0,dest=targetdir -i '/dir/file'
 ```
